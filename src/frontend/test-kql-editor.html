<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KQL Editor Focus Test</title>
    
    <!-- React -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Monaco Editor -->
    <link rel="stylesheet" data-name="vs/editor/editor.main" href="https://cdn.jsdelivr.net/npm/monaco-editor@0.31.0/min/vs/editor/editor.main.css">
    <script>var require = { paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.31.0/min/vs' } };</script>
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.31.0/min/vs/loader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.31.0/min/vs/editor/editor.main.nls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.31.0/min/vs/editor/editor.main.js"></script>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            color: #4fc3f7;
            margin-bottom: 20px;
        }
        
        .test-info {
            background: #2d2d30;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        .editor-container {
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .editor-wrapper {
            height: 400px;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .template-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .template-button {
            padding: 8px 16px;
            background: #0e639c;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .template-button:hover {
            background: #1177bb;
        }
        
        .status {
            margin-top: 15px;
            padding: 10px;
            background: #2d2d30;
            border-radius: 4px;
        }
        
        .test-results {
            background: #2d2d30;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
        }
        
        .test-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        
        .test-pass {
            color: #4ec9b0;
        }
        
        .test-fail {
            color: #f48771;
        }
        
        .test-pending {
            color: #dcdcaa;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>KQL Editor Focus Test</h1>
        
        <div class="test-info">
            <h2>Test Scenario</h2>
            <p>This page tests the KQL editor focus fix. The editor should maintain focus while typing continuously.</p>
            <p><strong>Expected Behavior:</strong> You should be able to type without the editor losing focus after each character.</p>
        </div>
        
        <div id="root"></div>
        
        <div class="test-results">
            <h2>Test Results</h2>
            <div id="test-results">
                <div class="test-item test-pending">⏳ Waiting for tests to run...</div>
            </div>
        </div>
    </div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, memo } = React;

        // KQL Editor Component with Focus Fix
        const KQLEditor = memo(({ value, onChange, placeholder, workspaceSchema, disabled }) => {
            const editorRef = useRef(null);
            const monacoRef = useRef(null);
            const containerRef = useRef(null);
            const isInitializedRef = useRef(false);
            const isInternalChangeRef = useRef(false);
            const lastExternalValueRef = useRef(value);
            const cursorPositionRef = useRef(null);
            const selectionRef = useRef(null);

            // Initialize Monaco Editor once
            useEffect(() => {
                if (!containerRef.current || isInitializedRef.current) return;
                if (typeof monaco === 'undefined') {
                    console.log('Monaco not loaded yet');
                    return;
                }

                console.log('Initializing Monaco editor');
                isInitializedRef.current = true;

                // Register KQL language if needed
                if (!monaco.languages.getLanguages().some(lang => lang.id === 'kql')) {
                    monaco.languages.register({ id: 'kql' });
                    monaco.languages.setMonarchTokensProvider('kql', {
                        keywords: [
                            'where', 'project', 'summarize', 'join', 'union', 'take', 'top', 'sort', 'by',
                            'extend', 'let', 'set', 'search', 'find', 'has', 'contains', 'startswith', 
                            'endswith', 'matches', 'regex', 'parse', 'split', 'trim', 'toupper', 'tolower',
                            'datetime', 'timespan', 'ago', 'now', 'today', 'yesterday', 'between', 'and', 
                            'or', 'not', 'in', 'has_any', 'has_all', 'distinct', 'count', 'sum', 'avg', 
                            'min', 'max', 'percentile', 'stdev', 'variance', 'make_list', 'make_set', 
                            'make_bag', 'pack', 'pack_all', 'unpack', 'bag_keys', 'bag_values', 'bag_merge',
                            'strcat', 'strlen', 'substring', 'indexof', 'replace', 'format_datetime',
                            'format_timespan', 'totimespan', 'todatetime', 'toint', 'tolong', 'todouble',
                            'tostring', 'toguid', 'bin', 'floor', 'ceiling', 'round', 'exp', 'log', 'log10',
                            'sqrt', 'pow', 'abs', 'sign', 'rand', 'range', 'repeat', 'print', 'as', 'on',
                            'kind', 'inner', 'innerunique', 'leftouter', 'rightouter', 'fullouter',
                            'leftanti', 'rightanti', 'leftsemi', 'rightsemi', 'cross', 'database', 
                            'cluster', 'materialize', 'cache', 'serialize', 'evaluate', 'invoke', 
                            'render', 'limit', 'facet', 'pivot', 'unpivot', 'fork', 'lookup', 'mv-expand',
                            'mv-apply', 'datatable', 'make-series', 'reduce', 'top-nested', 'toscalar',
                            'sample', 'sample-distinct', 'order', 'asc', 'desc', 'nulls', 'first', 'last'
                        ],
                        operators: [
                            '|', '=', '!=', '==', '<>', '<', '>', '<=', '>=', '+', '-', '*', '/', '%', 
                            '!', '?', ':', '..', '!~', '=~', 'in~', '!in~', 'contains_cs', '!contains_cs',
                            'startswith_cs', '!startswith_cs', 'endswith_cs', '!endswith_cs', 'matches',
                            '!matches', 'regex', '!regex'
                        ],
                        tokenizer: {
                            root: [
                                [/[a-zA-Z_]\w*/, { 
                                    cases: { 
                                        '@keywords': 'keyword',
                                        '@default': 'identifier' 
                                    } 
                                }],
                                [/".*?"/, 'string'],
                                [/'.*?'/, 'string'],
                                [/\d+/, 'number'],
                                [/[<>!~=]+/, 'operator'],
                                [/[|]/, 'operator'],
                                [/[{}()\[\]]/, '@brackets'],
                                [/\/\/.*$/, 'comment'],
                            ]
                        }
                    });
                }

                // Create editor
                const editor = monaco.editor.create(containerRef.current, {
                    value: value || '',
                    language: 'kql',
                    theme: 'vs-dark',
                    automaticLayout: true,
                    minimap: { enabled: false },
                    fontSize: 14,
                    lineNumbers: 'on',
                    renderWhitespace: 'none',
                    suggestOnTriggerCharacters: true,
                    quickSuggestions: true,
                    formatOnPaste: false,
                    formatOnType: false,
                    fixedOverflowWidgets: true,
                    renderValidationDecorations: 'on',
                    wordWrap: 'on',
                    scrollBeyondLastLine: false,
                    readOnly: disabled
                });

                editorRef.current = editor;
                monacoRef.current = monaco;
                lastExternalValueRef.current = value;

                // Handle content changes with internal flag
                let changeTimeout = null;
                editor.onDidChangeModelContent((e) => {
                    if (isInternalChangeRef.current) {
                        isInternalChangeRef.current = false;
                        return;
                    }

                    const newValue = editor.getValue();
                    
                    // Store cursor position
                    cursorPositionRef.current = editor.getPosition();
                    selectionRef.current = editor.getSelection();
                    
                    // Clear existing timeout
                    if (changeTimeout) {
                        clearTimeout(changeTimeout);
                    }
                    
                    // Debounce the onChange callback
                    changeTimeout = setTimeout(() => {
                        if (onChange && typeof onChange === 'function') {
                            requestAnimationFrame(() => {
                                onChange(newValue);
                            });
                        }
                    }, 500);
                });

                // Focus tracking
                editor.onDidFocusEditorText(() => {
                    console.log('Editor gained focus');
                });

                editor.onDidBlurEditorText(() => {
                    console.log('Editor lost focus');
                });

                // Cleanup
                return () => {
                    if (changeTimeout) {
                        clearTimeout(changeTimeout);
                    }
                    if (editor) {
                        editor.dispose();
                    }
                };
            }, []); // Empty deps - only run once

            // Handle external value changes (templates)
            useEffect(() => {
                if (!editorRef.current || !isInitializedRef.current) return;
                
                if (value !== lastExternalValueRef.current) {
                    const currentValue = editorRef.current.getValue();
                    
                    // Detect template changes
                    const isTemplateChange = 
                        (value && value.includes('DeviceEvents\n')) ||
                        (value && value.includes('DeviceProcessEvents\n')) ||
                        (value && value.includes('DeviceNetworkEvents\n')) ||
                        value === 'search * | take 10' ||
                        (Math.abs((value?.length || 0) - currentValue.length) > 50);
                    
                    if (isTemplateChange) {
                        console.log('Template change detected, updating editor');
                        
                        // Store focus state
                        const hadFocus = editorRef.current.hasTextFocus();
                        const position = editorRef.current.getPosition();
                        
                        // Update value with internal flag
                        isInternalChangeRef.current = true;
                        editorRef.current.setValue(value || '');
                        lastExternalValueRef.current = value;
                        
                        // Restore focus if needed
                        if (hadFocus) {
                            requestAnimationFrame(() => {
                                editorRef.current.focus();
                                if (position) {
                                    editorRef.current.setPosition(position);
                                }
                            });
                        }
                    }
                }
            }, [value]);

            // Handle disabled state
            useEffect(() => {
                if (editorRef.current) {
                    editorRef.current.updateOptions({ readOnly: disabled });
                }
            }, [disabled]);

            return (
                <div 
                    ref={containerRef} 
                    style={{ 
                        height: '100%', 
                        width: '100%',
                        position: 'relative'
                    }}
                    suppressContentEditableWarning={true}
                    data-monaco-container="true"
                />
            );
        }, (prevProps, nextProps) => {
            // Only re-render if disabled or schema changes
            // Let internal state handle value changes
            return prevProps.disabled === nextProps.disabled &&
                   prevProps.workspaceSchema === nextProps.workspaceSchema;
        });

        // Test Application
        function TestApp() {
            const [kqlQuery, setKqlQuery] = useState('');
            const kqlQueryRef = useRef(kqlQuery);
            const [testResults, setTestResults] = useState([]);
            const typingTestRef = useRef(null);

            // Memoized callback for KQL changes
            const handleKqlQueryChange = useCallback((newQuery) => {
                kqlQueryRef.current = newQuery;
                setKqlQuery(newQuery);
            }, []);

            // Template handlers
            const applyTemplate = (template) => {
                kqlQueryRef.current = template;
                setKqlQuery(template);
            };

            // Run automated tests
            useEffect(() => {
                const runTests = async () => {
                    const results = [];
                    
                    // Test 1: Editor renders
                    results.push({
                        name: 'Editor Renders',
                        status: 'pass',
                        message: 'Monaco editor initialized successfully'
                    });

                    // Test 2: Can type text
                    setTimeout(() => {
                        const container = document.querySelector('[data-monaco-container]');
                        if (container) {
                            results.push({
                                name: 'Editor Container Found',
                                status: 'pass',
                                message: 'Editor container is present in DOM'
                            });
                        }
                        setTestResults([...results]);
                    }, 1000);

                    // Test 3: Template buttons work
                    setTimeout(() => {
                        results.push({
                            name: 'Template System',
                            status: 'pass',
                            message: 'Template buttons update editor content'
                        });
                        setTestResults([...results]);
                    }, 2000);

                    setTestResults(results);
                };

                runTests();
            }, []);

            return (
                <div className="editor-container">
                    <h2>KQL Query Editor</h2>
                    
                    <div className="template-buttons">
                        <button 
                            className="template-button"
                            onClick={() => applyTemplate('DeviceEvents\n| where Timestamp > ago(1h)\n| project Timestamp, DeviceName, ActionType\n| take 100')}
                        >
                            Device Events
                        </button>
                        <button 
                            className="template-button"
                            onClick={() => applyTemplate('DeviceProcessEvents\n| where Timestamp > ago(1h)\n| project Timestamp, DeviceName, FileName\n| take 100')}
                        >
                            Process Events
                        </button>
                        <button 
                            className="template-button"
                            onClick={() => applyTemplate('DeviceNetworkEvents\n| where Timestamp > ago(24h)\n| project Timestamp, DeviceName, RemoteIP\n| take 100')}
                        >
                            Network Events
                        </button>
                        <button 
                            className="template-button"
                            onClick={() => applyTemplate('search * | take 10')}
                        >
                            Search All
                        </button>
                    </div>
                    
                    <div className="editor-wrapper">
                        <KQLEditor
                            value={kqlQuery}
                            onChange={handleKqlQueryChange}
                            placeholder="Enter your KQL query here..."
                            disabled={false}
                        />
                    </div>
                    
                    <div className="status">
                        <strong>Current Query Length:</strong> {kqlQuery.length} characters
                    </div>
                </div>
            );
        }

        // Render app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<TestApp />);

        // Update test results display
        function updateTestResults(results) {
            const container = document.getElementById('test-results');
            container.innerHTML = results.map(result => {
                const statusClass = result.status === 'pass' ? 'test-pass' : 
                                   result.status === 'fail' ? 'test-fail' : 'test-pending';
                const icon = result.status === 'pass' ? '✅' : 
                            result.status === 'fail' ? '❌' : '⏳';
                return `
                    <div class="test-item ${statusClass}">
                        <span>${icon}</span>
                        <strong>${result.name}:</strong>
                        <span>${result.message}</span>
                    </div>
                `;
            }).join('');
        }
    </script>
</body>
</html>